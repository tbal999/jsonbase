package jsonbase_archive

import (
	"crypto/sha256"
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math"
	"math/rand"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"text/tabwriter"
	"time"

	"github.com/cheggaaa/pb"
)

//Table is a struct containing the name, columns and rows of a table.
type Table struct {
	Name    string     `json:"Name"`
	Columns [][]string `json:"Columns"`
	Rows    [][]string `json:"Rows"`
}

//JSONBase is a struct that stores all tables.
type JSONBase struct {
	Table []Table `json:"Table"`
	lock  sync.RWMutex
}

type glfunc func(float64) float64

type gl2func func(float64, float64) float64

type cnfunc func(float64) bool

type cn2func func(float64, float64) bool

type txt2func func(string, string) bool

var (
	//Temptable is the internal buffer for storing any queries - printable via 'Output' function.
	//Exported just in case you want to access it directly.
	Temptable   [][]string
	hash1Dtable map[[32]byte][]string
	hashtable   map[[32]byte]string
	hashcount   map[[32]byte]int
)

func remove2D(slice [][]string, s int) [][]string {
	if s != len(slice) {
		slice = append(slice[:s], slice[s+1:]...)
		return slice
	} else if s == len(slice) {
		slice = slice[:len(slice)-1]
		return slice
	}
	return slice
}

func copy2D(input [][]string) [][]string {
	return input
}

func copy1D(input []string) []string {
	return input
}

func remove(slice [][]string, s int) [][]string {
	if s != len(slice) {
		slice = append(slice[:s], slice[s+1:]...)
		return slice
	} else if s == len(slice) {
		slice = slice[:len(slice)-1]
		return slice
	}
	return slice
}

func datetodays(x, parse string, delta float64) string {
	t, _ := time.Parse(parse, x)
	duration := time.Now().Add(time.Duration(delta) * (time.Hour * 24)).Sub(t)
	y := fmt.Sprintf("%d", int(duration.Hours()/24))
	return y
}

func minicheck(m map[int][]string, item1, item2 string) bool {
	for index := range m {
		_, real1 := contains(m[index], item1, 1)
		_, real2 := contains(m[index], item2, 1)
		if real1 == true && real2 == true {
			return true
		}
	}
	return false
}

func miniintcheck(m map[int][]int, item []int) bool {
	for index := range m {
		if m[index][0] == item[0] && m[index][1] == item[1] {
			return true
		}
	}
	return false
}

func contains(arr []string, str string, howmany int) (int, bool) {
	x := 0
	for index := range arr {
		if arr[index] == str {
			x++
		}
	}
	if x != 0 {
		return x, true
	}
	return 0, false
}

func containsint(arr []int, i int, howmany int) (int, bool) {
	x := 0
	for index := range arr {
		if arr[index] == i {
			x++
		}
	}
	if x != 0 {
		return x, true
	}
	return 0, false
}

func exists(arr []string, str string) bool {
	for index := range arr {
		if arr[index] == str {
			return true
		}
	}
	return false
}

func knn(training, testing [][]float64, trainingname, testingname []string, k int, train, regression bool) {
	output := [][]string{}
	bar := pb.StartNew(len(testing))
	for testindex := range testing {
		out := []struct {
			name   string
			number float64
		}{}
		bar.Increment()
		input := []string{}
		candidates := []string{}
		regdates := []float64{}
		if train == true {
			input = append(input, testingname[testindex])
		} else {
			input = append(input, strconv.Itoa(testindex+1))
		}
		var likely string
		for trainindex := range training {
			b := squareDistance(testing[testindex], training[trainindex])
			new := struct {
				name   string
				number float64
			}{trainingname[trainindex], b}
			out = append(out, new)
		}
		sort.SliceStable(out, func(i, j int) bool {
			return out[i].number < out[j].number
		})
		if k < len(out)-1 {
			for i := 0; i <= k; i++ {
				if regression == true {
					ax, _ := strconv.ParseFloat(out[i].name, 64)
					regdates = append(regdates, ax)
				} else {
					ix := out[i].name
					candidates = append(candidates, ix)
				}
			}
		} else {
			fmt.Printf("       The K number must be less than training sample size. Recommended starting number for this sample is %f\n", math.Sqrt(float64(len(training))))
			return
		}
		if regression == true {
			averagedata := calcaverage(regdates)
			input = append(input, averagedata)
			output = append(output, input)
		} else {
			likely = rangeMap(candidates)
			input = append(input, likely)
			output = append(output, input)
		}
	}
	bar.Finish()
	var counter float64
	if train == true && regression == false {
		for index := range output {
			if output[index][0] == output[index][1] {
				counter++
			}
		}
		fmt.Printf("%f success rate with K number of %d\n", (counter/float64(len(output)))*100, k)
	} else {
		Headers := []string{"INDEX", "PREDICTION"}
		Temptable = append(Temptable, Headers)
		for index := range output {
			Temptable = append(Temptable, output[index])
		}
	}
}

func calcaverage(items []float64) string {
	var average float64
	for index := range items {
		average += items[index]
	}
	output := average / float64(len(items))
	return strconv.FormatFloat(output, 'f', 4, 64)
}

func squareDistance(features1, features2 []float64) float64 {
	var d float64
	for i := range features1 {
		d += (features1[i] - features2[i]) * (features1[i] - features2[i])
	}
	return math.Sqrt(d)
}

func rangeMap(words []string) string {
	m := make(map[string]int)
	for _, word := range words {
		_, ok := m[word]
		if !ok {
			m[word] = 1
		} else {
			m[word]++
		}
	}
	min := 0
	var largest string
	for index := range m {
		if m[index] >= min {
			min = m[index]
			largest = index
		}
	}
	return largest
}

func hash(k string) [32]byte {
	h := sha256.Sum256([]byte(k))
	return h
}

func stringtofloat(key string) float64 {
	h := 0
	for i := 0; i < len(key); i++ {
		h = 31*h + int(key[i])
	}
	return float64(h)
}

func hash1D(k []string) [32]byte {
	join := strings.Join(k, "")
	h := sha256.Sum256([]byte(join))
	return h
}

func countingof(table *[]int, str *[]string, item string) {
	t := *table
	s := *str
	index, boolean := contains(s, item, 1)
	if boolean == false {
		s = append(s, item)
		t = append(t, 1)
	} else {
		t[index]++
	}
	*table = t
	*str = s
}

func (p JSONBase) meanall(tableindex, columnindex int) (float64, float64) {
	var sum float64
	var howmany = float64(len(p.Table[tableindex].Rows))
	for index := range p.Table[tableindex].Rows {
		x, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][columnindex], 64)
		sum += x
	}
	mean := sum / howmany
	var variance float64
	for index := range p.Table[tableindex].Rows {
		x, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][columnindex], 64)
		variance += (x - mean) * (x - mean)
	}
	return mean, math.Sqrt(variance) //standard deviation
}

func addslice(two *[][]string, one []string) {
	a := *two
	a = append(a, one)
	*two = a
}

func addstring(a []string, b string) []string {
	a = append(a, b)
	return a
}

func joinprint(x, y []string) {
	x = append(x, y...)
	Temptable = append(Temptable, x)
}

func grabsubstring(x string) (string, string) {
	if yes, _ := regexp.MatchString(`\[([^\[\]]*)\]`, x); yes == true {
		re := regexp.MustCompile(`\[([^\[\]]*)\]`)
		submatchall := re.FindAllString(x, -1)
		for _, element := range submatchall {
			element = strings.Trim(element, "[")
			element = strings.Trim(element, "]")
			return element, strings.Split(x, "[")[0]
		}
	}
	return "", strings.Split(x, "[")[0]
}

func (p JSONBase) mean(tableindex, columnindex, dependentcolumn int, item string) (float64, float64) {
	var sum float64
	var howmany float64
	for index := range p.Table[tableindex].Rows {
		if p.Table[tableindex].Rows[index][dependentcolumn] == item {
			howmany++
			x, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][columnindex], 64)
			sum += x
		}
	}
	mean := sum / howmany
	var variance float64
	for index := range p.Table[tableindex].Rows {
		if p.Table[tableindex].Rows[index][dependentcolumn] == item {
			x, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][columnindex], 64)
			variance += (x - mean) * (x - mean)
		}
	}
	return mean, math.Sqrt(variance) //standard deviation
}

func (j *JSONBase) put(item string) {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash(item)
	if hashtable == nil {
		hash1Dtable = make(map[[32]byte][]string)
	}
	hashtable[i] = item
}

func (j *JSONBase) get(item string) (string, [32]byte) {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash(item)
	return hashtable[i], i
}

func (j *JSONBase) put1D(item []string) {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash1D(item)
	if hashtable == nil {
		hash1Dtable = make(map[[32]byte][]string)
	}
	hash1Dtable[i] = item
}

func (j *JSONBase) get1D(item []string) []string {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash1D(item)
	return hash1Dtable[i]
}

func (j *JSONBase) hashadd(item string) {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash(item)
	if hashcount == nil {
		hashcount = make(map[[32]byte]int)
	}
	if hashcount[i] == 0 {
		hashcount[i] = 1
	} else {
		hashcount[i] = hashcount[i] + 1
	}
}

func (j *JSONBase) hash1Dadd(item []string) {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash1D(item)
	if hashcount == nil {
		hashcount = make(map[[32]byte]int)
	}
	if hashcount[i] == 0 {
		hashcount[i] = 1
	} else {
		hashcount[i] = hashcount[i] + 1
	}
}

func (j *JSONBase) hashget(item string) int {
	j.lock.Lock()
	defer j.lock.Unlock()
	i := hash(item)
	if hashcount == nil {
		hashcount = make(map[[32]byte]int)
	}
	return hashcount[i]
}

func (p JSONBase) grabindexes(table, column string) (int, int, bool) {
	tableindex, real := p.grabindex(table)
	if real == true {
		columnindex, real2 := p.grabcolumnindex(tableindex, column)
		if real2 == true {
			return tableindex, columnindex, true
		}
	}
	return 0, 0, false
}

func (p JSONBase) grabindex(name string) (int, bool) {
	for index := range p.Table {
		if p.Table[index].Name == name {
			return index, true
		}
	}
	return 0, false
}

func (p JSONBase) grabcolumnindex(index int, name string) (int, bool) {
	if len(p.Table[index].Columns) != 0 {
		for indexone := range p.Table[index].Columns[0] {
			if p.Table[index].Columns[0][indexone] == name {
				return indexone, true
			}
		}
	}
	return 0, false
}

func (p JSONBase) joincolumns(table1index, table2index int) []string {
	output := []string{}
	for index := range p.Table[table1index].Columns[0] {
		output = append(output, p.Table[table1index].Name+"_"+p.Table[table1index].Columns[0][index])
	}
	for index := range p.Table[table2index].Columns[0] {
		output = append(output, p.Table[table2index].Name+"_"+p.Table[table2index].Columns[0][index])
	}
	return output
}

func (p JSONBase) join2D(x, y []string) []string {
	z := append(x, y...)
	return z
}

//Verify verifies if Temptable has been populated - and how many rows (minus columns)
func (p JSONBase) Verify() (int, bool) {
	if len(Temptable) != 0 {
		return len(Temptable) - 1, true
	}
	return 0, false
}

//Clear the Temptable buffer at any time.
func (p *JSONBase) Clear() {
	Temptable = [][]string{}
}

//Print prints out the Temptable, bool lets you determine if table is cleared after print.
//Howmany is how many rows you want printed (0 for all rows)
func (p *JSONBase) Print(clear bool, howmany int) [][]string {
	max := 0
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.Debug)
	if len(Temptable) == 0 {
		fmt.Println("No results.")
		return nil
	}
	if howmany == 0 {
		for index := range Temptable {
			out := strings.Join(Temptable[index], "\t")
			fmt.Fprintln(w, out)
		}
	} else {
		for index := range Temptable {
			out := strings.Join(Temptable[index], "\t")
			fmt.Fprintln(w, out)
			max++
			if max > howmany {
				break
			}
		}
	}
	w.Flush()
	if clear == true {
		p.Clear()
	}
	return Temptable
}

//SaveBuffer lets you save the current Temptable as a jsonbase table - name is the name of the table, howmany is how many rows you want to save
//clear is whether you want to clear the buffer after you've saved it.
func (p *JSONBase) SaveBuffer(name string, howmany int, clear bool) {
	jsonbase := *p
	max := 0
	Table := Table{}
	Table.Name = name
	if len(Temptable) == 0 {
		fmt.Println("No results.")
		return
	}
	if howmany == 0 {
		for index := range Temptable {
			if index == 0 {
				Table.Columns = append(Table.Columns, Temptable[index])
			} else {
				Table.Rows = append(Table.Rows, Temptable[index])
			}
		}
	} else {
		for index := range Temptable {
			if index == 0 {
				Table.Columns = append(Table.Columns, Temptable[index])
			} else {
				Table.Rows = append(Table.Rows, Temptable[index])
				max++
			}
			if max >= howmany {
				break
			}
		}
	}
	jsonbase.Table = append(jsonbase.Table, Table)
	*p = jsonbase
	if clear == true {
		p.Clear()
	}
}

//ExportAsCSV lets you export temptable buffer as a CSV file.
func (p *JSONBase) ExportAsCSV(filename string) {
	os.Remove(filename)
	csvFile, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed creating file: %s", err)
	}
	csvwriter := csv.NewWriter(csvFile)
	for index2 := range Temptable {
		csvwriter.Write(Temptable[index2])
	}
	if err := csvwriter.Error(); err != nil {
		log.Fatalln("error writing csv:", err)
	}
	csvwriter.Flush()
	csvFile.Close()
}

//Normalize - normalises the data in a table.
func (p *JSONBase) Normalize(table string) {
	j := *p
	table1index, real := j.grabindex(table)
	if real == true {
		for columnindex := range j.Table[table1index].Columns[0] {
			mean, dev := p.meanall(table1index, columnindex)
			for row := range j.Table[table1index].Rows {
				x, _ := strconv.ParseFloat(p.Table[table1index].Rows[row][columnindex], 64)
				x = (x - mean) / dev
				p.Table[table1index].Rows[row][columnindex] = strconv.FormatFloat(x, 'f', 2, 64)
			}
		}
	}
	*p = j
}

//Export2DSlice is a quick and easy way to export a 2D slice.
func (p JSONBase) Export2DSlice(slice [][]string, filename string) {
	csvFile, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed creating file: %s", err)
	}
	csvwriter := csv.NewWriter(csvFile)
	for index2 := range slice {
		csvwriter.Write(slice[index2])
	}
	if err := csvwriter.Error(); err != nil {
		log.Fatalln("error writing csv:", err)
	}
	csvwriter.Flush()
	csvFile.Close()
}

//RegexHelp just prints instructions on how to use regular expressions.
//If stuck, place this function in go and maybe fmt.Scanln() to read it.
func (p JSONBase) RegexHelp() {
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.Debug)
	var tobeprinted = `Syntax (from https://golang.org/pkg/regexp/syntax/)

Parts of the syntax can be disabled by passing alternate flags to Parse.

Single characters:
.              any character, possibly including newline (flag s=true)
[xyz]          character class
[^xyz]         negated character class
\d             Perl character class
\D             negated Perl character class
[[:alpha:]]    ASCII character class
[[:^alpha:]]   negated ASCII character class
\pN            Unicode character class (one-letter name)
\p{Greek}      Unicode character class
\PN            negated Unicode character class (one-letter name)
\P{Greek}      negated Unicode character class

Composites:
xy             x followed by y
x|y            x or y (prefer x)

Repetitions:
x*             zero or more x, prefer more
x+             one or more x, prefer more
x?             zero or one x, prefer one
x{n,m}         n or n+1 or ... or m x, prefer more
x{n,}          n or more x, prefer more
x{n}           exactly n x
x*?            zero or more x, prefer fewer
x+?            one or more x, prefer fewer
x??            zero or one x, prefer zero
x{n,m}?        n or n+1 or ... or m x, prefer fewer
x{n,}?         n or more x, prefer fewer
x{n}?          exactly n x


Grouping:
(re)           numbered capturing group (submatch)
(?P<name>re)   named & numbered capturing group (submatch)
(?:re)         non-capturing group
(?flags)       set flags within current group; non-capturing
(?flags:re)    set flags during re; non-capturing

Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:
i              case-insensitive (default false)
m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)
s              let . match \n (default false)
U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)

Empty strings:
^              at beginning of text or line (flag m=true)
$              at end of text (like \z not Perl's \Z) or line (flag m=true)
\A             at beginning of text
\b             at ASCII word boundary (\w on one side and \W, \A, or \z on the other)
\B             not at ASCII word boundary
\z             at end of text

Escape sequences:
\a             bell (== \007)
\f             form feed (== \014)
\t             horizontal tab (== \011)
\n             newline (== \012)
\r             carriage return (== \015)
\v             vertical tab character (== \013)
\*             literal *, for any punctuation character *
\123           octal character code (up to three digits)
\x7F           hex character code (exactly two digits)
\x{10FFFF}     hex character code
\Q...\E        literal text ... even if ... has punctuation

Character class elements:
x              single character
A-Z            character range (inclusive)
\d             Perl character class
[:foo:]        ASCII character class foo
\p{Foo}        Unicode character class Foo
\pF            Unicode character class F (one-letter name)

Named character classes as character class elements:
[\d]           digits (== \d)
[^\d]          not digits (== \D)
[\D]           not digits (== \D)
[^\D]          not not digits (== \d)
[[:name:]]     named ASCII class inside character class (== [:name:])
[^[:name:]]    named ASCII class inside negated character class (== [:^name:])
[\p{Name}]     named Unicode property inside character class (== \p{Name})
[^\p{Name}]    named Unicode property inside negated character class (== \P{Name})

Perl character classes (all ASCII-only):
\d             digits (== [0-9])
\D             not digits (== [^0-9])
\s             whitespace (== [\t\n\f\r ])
\S             not whitespace (== [^\t\n\f\r ])
\w             word characters (== [0-9A-Za-z_])
\W             not word characters (== [^0-9A-Za-z_])

ASCII character classes:
[[:alnum:]]    alphanumeric (== [0-9A-Za-z])
[[:alpha:]]    alphabetic (== [A-Za-z])
[[:ascii:]]    ASCII (== [\x00-\x7F])
[[:blank:]]    blank (== [\t ])
[[:cntrl:]]    control (== [\x00-\x1F\x7F])
[[:digit:]]    digits (== [0-9])
[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_{|}~])
[[:lower:]]    lower case (== [a-z])
[[:print:]]    printable (== [ -~] == [ [:graph:]])
[[:punct:]]    punctuation (== [!-/:-@[-{-~])
[[:space:]]    whitespace (== [\t\n\v\f\r ])
[[:upper:]]    upper case (== [A-Z])
[[:word:]]     word characters (== [0-9A-Za-z_])
[[:xdigit:]]   hex digit (== [0-9A-Fa-f])
`
	fmt.Fprintln(w, tobeprinted)
	w.Flush()
}

//ImportFile lets you import delimited flat files. filename is the name of file, delimiter is the delimiter that the file is delimited by.
//Set 'header' to true if there's a header for the file, otherwise set to false.
//Header is only for rune delimited files i.e a comma, it doesn't matter what you set it to if the file is delimited by '\n'
func (p *JSONBase) ImportFile(filename, tablename, delimiter string, header bool) {
	File := *p
	Table := Table{}
	if filename == "" || tablename == "" {
		fmt.Println("Need a file / tablename.")
		return
	}
	if delimiter != "\n" && delimiter != "\r\n" {
		f, _ := os.Open(filename)
		r := csv.NewReader(f)
		r.Comma = rune(delimiter[0])
		r.LazyQuotes = true
		r.FieldsPerRecord = -1
		count := 0
		for {
			record, err := r.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				return
			}
			for index := range record {
				record[index] = strings.Replace(record[index], "\"", "", -1)
				record[index] = strings.Replace(record[index], ",", "", -1)
			}
			if header == true {
				if count == 0 {
					Table.Columns = append(Table.Columns, record)
				} else {
					Table.Rows = append(Table.Rows, record)
				}
			} else {
				Table.Rows = append(Table.Rows, record)
			}
			count++
		}
		if header == false {
			head := ""
			for x := 0; x < len(Table.Rows[0]); x++ {
				head += "COLUMN" + strconv.Itoa(x)
				if x != len(Table.Rows[0])-1 {
					head += ","
				}
			}
			Table.Columns = append(Table.Columns, strings.Split(head, ","))
		}
	} else {
		content, err := ioutil.ReadFile(filename)
		if err != nil {
			log.Fatal(err)
		}
		s := strings.Split(string(content), delimiter)
		Columns := []string{"COLUMN1"}
		Table.Columns = append(Table.Columns, Columns)
		for index := range s {
			rows := []string{s[index]}
			Table.Rows = append(Table.Rows, rows)
		}
	}
	Table.Name = tablename
	File.Table = append(File.Table, Table)
	*p = File
}

//Import2DString lets you import 2D string arrays. filename is the name of file, delimiter is the delimiter that the string array is delimited by.
//header is true or false depending on whether there's columns in the data, if not, auto generated columns will be added.
func (p *JSONBase) Import2DString(input [][]string, tablename, delimiter string, header bool) {
	File := *p
	Table := Table{}
	Table.Name = tablename
	for index := range input {
		tobeadded := strings.Join(input[index], delimiter)
		if header == true {
			if index == 0 {
				Table.Columns = append(Table.Columns, strings.Split(tobeadded, delimiter))
			} else {
				Table.Rows = append(Table.Rows, strings.Split(tobeadded, delimiter))
			}
		} else {
			Table.Rows = append(Table.Rows, strings.Split(tobeadded, delimiter))
		}
	}
	if header == false {
		head := ""
		for x := 0; x < len(Table.Rows[0]); x++ {
			head += "COLUMN" + strconv.Itoa(x)
			if x != len(Table.Rows[0])-1 {
				head += ","
			}
		}
		Table.Columns = append(Table.Columns, strings.Split(head, ","))
	}
	File.Table = append(File.Table, Table)
	*p = File
}

//Import1DString lets you import 1D string arrays. filename is the name of file, delimiter is the delimiter that the string array is delimited by.
//header is true or false depending on whether there's columns in the data, if not, auto generated columns will be added.
func (p *JSONBase) Import1DString(input []string, tablename, delimiter string, header bool) {
	File := *p
	Table := Table{}
	Table.Name = tablename
	for index := range input {
		if header == true {
			if index == 0 {
				Table.Columns = append(Table.Columns, strings.Split(input[index], delimiter))
			} else {
				Table.Rows = append(Table.Rows, strings.Split(input[index], delimiter))
			}
		} else {
			Table.Rows = append(Table.Rows, strings.Split(input[index], delimiter))
		}
	}
	if header == false {
		head := ""
		for x := 0; x < len(Table.Rows[0]); x++ {
			head += "COLUMN" + strconv.Itoa(x)
			if x != len(Table.Rows[0])-1 {
				head += ","
			}
		}
		Table.Columns = append(Table.Columns, strings.Split(head, ","))
	}
	File.Table = append(File.Table, Table)
	*p = File
}

//ImportString lets you import strings delimited by EOL. filename is the name of file, delimiter is the delimiter that the string array is delimited by.
//header is true or false depending on whether there's columns in the data, if not, auto generated columns will be added.
func (p *JSONBase) ImportString(input string, tablename, delimiter string, header bool) {
	File := *p
	Table := Table{}
	stage1 := strings.Split(input, "\n")
	Table.Name = tablename
	for index := range stage1 {
		if header == true {
			if index == 0 {
				Table.Columns = append(Table.Columns, strings.Split(stage1[index], delimiter))
			} else {
				Table.Rows = append(Table.Rows, strings.Split(stage1[index], delimiter))
			}
		} else {
			Table.Rows = append(Table.Rows, strings.Split(stage1[index], delimiter))
		}
	}
	if header == false {
		head := ""
		for x := 0; x < len(Table.Rows[0]); x++ {
			head += "COLUMN" + strconv.Itoa(x)
			if x != len(Table.Rows[0])-1 {
				head += ","
			}
		}
		Table.Columns = append(Table.Columns, strings.Split(head, ","))
	}
	File.Table = append(File.Table, Table)
	*p = File
}

//GrabTable lets you grab a table by name and then places the table columns/rows in the Temptable buffer.
//Passes to Buffer
func (p JSONBase) GrabTable(name string) {
	index, real := p.grabindex(name)
	if real == true && len(p.Table[index].Columns) != 0 && len(p.Table[index].Rows) != 0 {
		Temptable = append(Temptable, p.Table[index].Columns[0])
		for index2 := range p.Table[index].Rows {
			Temptable = append(Temptable, p.Table[index].Rows[index2])
		}
	}
}

//Sum lets you count sum of total in a column of integers
//Passes to Buffer
func (p JSONBase) Sum(table, column string) {
	var sum float64
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true && len(p.Table[tableindex].Columns) != 0 && len(p.Table[tableindex].Rows) != 0 {
		headerstring := []string{}
		headerstring = append(headerstring, p.Table[tableindex].Columns[0][tablecolumn])
		Temptable = append(Temptable, headerstring)
		for index2 := range p.Table[tableindex].Rows {
			number, err := strconv.ParseFloat(p.Table[tableindex].Rows[index2][tablecolumn], 64)
			if err != nil {
				fmt.Println("There are non-integers in this column")
				return
			}
			sum += number
		}
	}
	sumstring := []string{}
	sumstring = append(sumstring, strconv.FormatFloat(sum, 'f', 2, 64))
	Temptable = append(Temptable, sumstring)
}

//Regex lets you grab a table where items within a column match a regular expression that you can pass in
//to the function and pulls whether they do or don't match (true/false)
//Passes to Buffer
func (p JSONBase) Regex(table, column, regexquery string, boolean bool) {
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		Temptable = append(Temptable, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
			if match, _ := regexp.MatchString(regexquery, p.Table[tableindex].Rows[index][tablecolumn]); match == boolean {
				Temptable = append(Temptable, p.Table[tableindex].Rows[index])
			}
		}
	}
}

//Shuffle lets you split up a training dataset into two tables of 50:50 ratio.
//to the function and pulls whether they do or don't match (true/false)
//Passes to Buffer
func (p JSONBase) Shuffle(table string) {
	tableindex, real := p.grabindex(table)
	if real == true {
		r := rand.New(rand.NewSource(time.Now().Unix()))
		for index, i := range r.Perm(len(p.Table[tableindex].Rows)) {
			p.Table[tableindex].Rows[index] = p.Table[tableindex].Rows[i]
		}
	}
}

//RegexReplace lets you replace substrings in strings with new string for rows that match a Regex.
//Directly affects table
//Afterwards you will need to Grab the table.
func (p JSONBase) RegexReplace(table, column, regexquery, replace, new string) {
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		for index := range p.Table[tableindex].Rows {
			if match, _ := regexp.MatchString(regexquery, p.Table[tableindex].Rows[index][tablecolumn]); match == true {
				p.Table[tableindex].Rows[index][tablecolumn] = strings.Replace(p.Table[tableindex].Rows[index][tablecolumn], replace, new, -1)
			}
		}
	}
}

//CalculationInt lets you do calculations on the rows of a numerical column.
//You can pass a function of type func(column float64) float64.
//Directly affects table & adds another column (column name + _1D)
//Digits is how many decimal places the results will be
func (p JSONBase) CalculationInt(table, column string, function glfunc, decimals int) {
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		p.Table[tableindex].Columns[0] = append(p.Table[tableindex].Columns[0], column+"_1D")
		for index := range p.Table[tableindex].Rows {
			number, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn], 64)
			p.Table[tableindex].Rows[index][tablecolumn] = strconv.FormatFloat(function(number), 'f', decimals, 64)
		}
	}
}

//Calculation2DInt lets you do calculations on the rows of two numerical columns.
//You can pass a function of type func(column1, column2 float64) float64.
//Directly affects table & adds another column (column1 name + _2D_ + column2 name)
//Digits is how many decimal places the results will be
func (p JSONBase) Calculation2DInt(table, column1, column2 string, function gl2func, decimals int) {
	tableindex, tablecolumn, real := p.grabindexes(table, column1)
	_, tablecolumn2, real2 := p.grabindexes(table, column2)
	if real == true && real2 == true {
		p.Table[tableindex].Columns[0] = append(p.Table[tableindex].Columns[0], column1+"_2D_"+column2)
		for index := range p.Table[tableindex].Rows {
			number1, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn], 64)
			number2, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn2], 64)
			p.Table[tableindex].Rows[index] = append(p.Table[tableindex].Rows[index], strconv.FormatFloat(function(number1, number2), 'f', decimals, 64))
		}
	}
}

//ConditionalInt lets you do conditionals on an integer column.
//You can pass a function of type func(x float64) bool.
//Passes to Buffer
//Results that are true will be returned
func (p JSONBase) ConditionalInt(table, column string, function cnfunc) {
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		Temptable = append(Temptable, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
			number, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn], 64)
			if function(number) == true {
				Temptable = append(Temptable, p.Table[tableindex].Rows[index])
			}
		}
	}
}

//Conditional2DInt lets you do conditionals on two integer columns at once.
//You can pass a function of type func(x, y float64) bool.
//Passes to Buffer
//Results that are true will be returned
func (p JSONBase) Conditional2DInt(table, column1, column2 string, function cn2func) {
	tableindex, tablecolumn, real := p.grabindexes(table, column1)
	_, tablecolumn2, real2 := p.grabindexes(table, column2)
	if real == true && real2 == true {
		Temptable = append(Temptable, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
			number1, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn], 64)
			number2, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn2], 64)
			if function(number1, number2) == true {
				Temptable = append(Temptable, p.Table[tableindex].Rows[index])
			}
		}
	}
}

//Conditional2DText lets you do conditionals on two string columns at once.
//You can pass a function of type func(x, y string) bool.
//Passes to Buffer
//Results that are true will be returned
func (p JSONBase) Conditional2DText(table, column1, column2 string, function txt2func) {
	tableindex, tablecolumn, real := p.grabindexes(table, column1)
	_, tablecolumn2, real2 := p.grabindexes(table, column2)
	if real == true && real2 == true {
		Temptable = append(Temptable, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
			string1 := p.Table[tableindex].Rows[index][tablecolumn]
			string2 := p.Table[tableindex].Rows[index][tablecolumn2]
			if function(string1, string2) == true {
				Temptable = append(Temptable, p.Table[tableindex].Rows[index])
			}
		}
	}
}

//DateToDays converts all dates in a column to days from today and then adds a new column called 'DateToDays'
//Directly Affects Table
//just choose table and column, parse is for what the date layout is i.e
//example - if it is SQL layout 2006-01-02T15:04:05-0700 then you want to write in '2006-01-02T15:04:05-0700'
func (p JSONBase) DateToDays(table, column, parse string, delta float64) {
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		p.Table[tableindex].Columns[0] = append(p.Table[tableindex].Columns[0], column+"_days")
		for index := range p.Table[tableindex].Rows {
			p.Table[tableindex].Rows[index] = append(p.Table[tableindex].Rows[index], datetodays(p.Table[tableindex].Rows[index][tablecolumn], parse, delta))
		}
	}
}

//Columns returns an array of the columns in a specific table (used for when you want to do adjustments on multiple columns quickly i.e remove whitespaces)
func (p JSONBase) Columns(table string) []string {
	tableindex, real := p.grabindex(table)
	if real == true {
		return p.Table[tableindex].Columns[0]
	}
	fmt.Println("This table does not exist")
	return nil
}

//Order re-orders a disorderly set of data by one column of integers
//Directly affects table.
//boolean true for ASC false for DESC
func (p JSONBase) Order(table, column string, order bool) {
	listofints := []float64{}
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		for index := range p.Table[tableindex].Rows {
			number, _ := strconv.ParseFloat(p.Table[tableindex].Rows[index][tablecolumn], 64)
			listofints = append(listofints, number)
		}
		if order == true {
			sort.SliceStable(p.Table[tableindex].Rows, func(i, j int) bool {
				return p.Table[tableindex].Rows[i][tablecolumn] < p.Table[tableindex].Rows[j][tablecolumn]
			})
		} else {
			sort.SliceStable(p.Table[tableindex].Rows, func(i, j int) bool {
				return p.Table[tableindex].Rows[i][tablecolumn] > p.Table[tableindex].Rows[j][tablecolumn]
			})
		}
	}
}

//AddIndex adds index column
//Integer is where index starts from i.e 0 = starts from 0, -1 = starts from -1
//Passes to Buffer
func (p JSONBase) AddIndex(start int) {
	for index := range Temptable {
		if index == 0 {
			Temptable[index] = append(Temptable[index], "INDEX")
		} else {
			Temptable[index] = append(Temptable[index], strconv.Itoa(index+start-1))
		}
	}
}

//AddString adds a string on every row at end column - useful for some situations
//Passes to Buffer
func (p JSONBase) AddString(thestring string) {
	for index := range Temptable {
		if index == 0 {
			Temptable[index] = append(Temptable[index], "ASTRING")
		} else {
			Temptable[index] = append(Temptable[index], thestring)
		}
	}
}

//Row lets you grab a specific row number of items that have already been orderered.
//Passes to Buffer
func (p JSONBase) Row(table, column string, rownumber int) {
	stringlist := []string{}
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		Temptable = append(Temptable, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
		inter:
			stringlist = append(stringlist, p.Table[tableindex].Rows[index][tablecolumn])
			count, yes := contains(stringlist, p.Table[tableindex].Rows[index][tablecolumn], rownumber)
			if rownumber == count && yes == true {
				Temptable = append(Temptable, p.Table[tableindex].Rows[index])
				goto inter
			}
		}
	}
}

//Count lets you count the number of instances of all unique row items in column 'column' in table 'table'.
//Passes to Buffer
func (p JSONBase) Count(table, column string) {
	hashtable = make(map[[32]byte]string)
	hashcount = make(map[[32]byte]int)
	header := []string{table + "_" + column + "_ITEM", table + "_" + column + "_COUNT"}
	Temptable = append(Temptable, header)
	tableindex, tablecolumn, real := p.grabindexes(table, column)
	if real == true {
		for index := range p.Table[tableindex].Rows {
			if grab, _ := p.get(p.Table[tableindex].Rows[index][tablecolumn]); grab == "" {
				p.put(p.Table[tableindex].Rows[index][tablecolumn])
				p.hashadd(p.Table[tableindex].Rows[index][tablecolumn])
			} else {
				p.hashadd(p.Table[tableindex].Rows[index][tablecolumn])
			}
		}
	}
	for key := range hashtable {
		str := hashtable[key] + "," + strconv.Itoa(p.hashget(hashtable[key]))
		newitem := strings.Split(str, ",")
		addslice(&Temptable, newitem)
	}
}

//Join is: left join table1 on table1.column1 = table2.column2
//Passes to Buffer
func (p JSONBase) Join(table1, column1, table2, column2 string) {
	hash1Dtable = make(map[[32]byte][]string)
	table1index, real1 := p.grabindex(table1)
	table2index, real2 := p.grabindex(table2)
	if real1 && real2 == true {
		tablecolumn1, real3 := p.grabcolumnindex(table1index, column1)
		tablecolumn2, real4 := p.grabcolumnindex(table2index, column2)
		if real3 && real4 == true {
			Temptable = append(Temptable, p.joincolumns(table1index, table2index))
			var abool bool
			for yindex := range p.Table[table1index].Rows {
				abool = false
				for xindex := range p.Table[table2index].Rows {
					if p.Table[table1index].Rows[yindex][tablecolumn1] == p.Table[table2index].Rows[xindex][tablecolumn2] {
						abool = true
						if item := p.get1D(p.join2D(p.Table[table1index].Rows[yindex], p.Table[table2index].Rows[xindex])); item == nil {
							p.put1D(p.join2D(p.Table[table1index].Rows[yindex], p.Table[table2index].Rows[xindex]))
							Temptable = append(Temptable, p.join2D(p.Table[table1index].Rows[yindex], p.Table[table2index].Rows[xindex]))
						}
					}
				}
				if abool == false {
					var null = []string{"NULL-DATA"}
					Temptable = append(Temptable, p.join2D(p.Table[table1index].Rows[yindex], null))
				}
			}
		}
	}
}

//LoadJSONBase lets you load a jsonbase that you have previously saved for some reason
func (p *JSONBase) LoadJSONBase(filename string) {
	item := *p
	jsonFile, _ := ioutil.ReadFile(filename + ".json")
	_ = json.Unmarshal([]byte(jsonFile), &item)
	*p = item
	fmt.Println("Loaded " + filename + "!")
}

//SaveJSONBase lets you save a jsonbase that you are currently working with
func (p JSONBase) SaveJSONBase(filename string) {
	Base := &p
	output, err := json.MarshalIndent(Base, "", "\t")
	if err != nil {
		fmt.Println(err)
		return
	}
	_ = ioutil.WriteFile(filename+".json", output, 0755)
	fmt.Println("Saved " + filename + "!")
}

//GetBuffer lets you pull a copy of the Temptable buffer directly (boolean is for whether you want to include columns or not)
func (p JSONBase) GetBuffer(includecolumns bool) [][]string {
	if includecolumns == true {
		return Temptable
	}
	return Temptable[1:]
}

//PutBuffer lets you replace buffer directly with a new 2D string array
func (p JSONBase) PutBuffer(input [][]string) {
	Temptable = input
}

//DeleteBufferRow deletes a row in the buffer at i index (Columns are index 0).
func (p JSONBase) DeleteBufferRow(i int) {
	Temptable = remove2D(Temptable, i)
}

//Select lets you trim columns in temptable buffer to specific columns.
//You must pass in a 1D string array of column headers.
//Passes to Buffer
func (p JSONBase) Select(columns []string) {
	replacers := []string{}
	for index := range columns {
		if output, item := grabsubstring(columns[index]); output != "" {
			replacers = append(replacers, output)
			columns[index] = item
		} else {
			replacers = append(replacers, item)
			columns[index] = item
		}
	}
	mainindex := []int{}
	newoutput := [][]string{}
	for tempindex := range Temptable[0] {
		for columnindex := range columns {
			if Temptable[0][tempindex] == columns[columnindex] {
				mainindex = append(mainindex, tempindex)
			}
		}
	}
	for index1 := range Temptable {
		output := []string{}
		if index1 != 0 {
			for index2 := range mainindex {
				output = append(output, Temptable[index1][mainindex[index2]])
			}
		} else {
			for indexx := range replacers {
				output = append(output, replacers[indexx])
			}

		}
		addslice(&newoutput, output)
	}
	Temptable = newoutput
}

//Timer lets you track how long queries take (try defer Timer(time.Now()))
func (p JSONBase) Timer(start time.Time) {
	elapsed := time.Since(start)
	log.Printf("This took %s", elapsed)
}

//Describe - pass a table & a dependent column to describe table around that column.
func (p *JSONBase) Describe(table, dependentcolumn string) {
	columnnames := []string{}
	tableindex, dependentcolumnindex, real := p.grabindexes(table, dependentcolumn)
	if real == true {
		for index2 := range p.Table[tableindex].Rows {
			if _, yes := contains(columnnames, p.Table[tableindex].Rows[index2][dependentcolumnindex], 1); yes == false {
				columnnames = append(columnnames, p.Table[tableindex].Rows[index2][dependentcolumnindex])
			}
		}
	}
	for index := range columnnames {
		fmt.Println("MEAN / STANDARD DEVIATION for " + columnnames[index])
		for index2 := range p.Table[tableindex].Columns[0] {
			if p.Table[tableindex].Columns[0][index2] != dependentcolumn {
				mean, dev := p.mean(tableindex, index2, dependentcolumnindex, columnnames[index])
				fmt.Printf("For column '%s' - average is %f, standard deviation is %f\n", p.Table[tableindex].Columns[0][index2], mean, dev)
			}
		}
	}
}

//Split - split a set of training data up into two new tables (training / testing) at a certain ratio i.e 2 will be 50/50.
func (p *JSONBase) Split(table, trainingname, testname string, ratio int) {
	js := *p
	Testtable := Table{}
	Testtable.Name = testname
	Trainingtable := Table{}
	Trainingtable.Name = trainingname
	tableindex, real := p.grabindex(table)
	p.Shuffle(table)
	if real == true {
		Testtable.Columns = append(Testtable.Columns, p.Table[tableindex].Columns[0])
		Trainingtable.Columns = append(Trainingtable.Columns, p.Table[tableindex].Columns[0])
		for index := range p.Table[tableindex].Rows {
			if index%ratio == 0 {
				Testtable.Rows = append(Testtable.Rows, p.Table[tableindex].Rows[index])
			} else {
				Trainingtable.Rows = append(Trainingtable.Rows, p.Table[tableindex].Rows[index])
			}
		}
	}
	js.Table = append(js.Table, Testtable)
	js.Table = append(js.Table, Trainingtable)
	fmt.Printf("Training size: %d\n", len(Trainingtable.Rows))
	fmt.Printf("Test size: %d\n", len(Testtable.Rows))
	*p = js
}

//KNN classifier using trainingtable to predict output on testtable using identifiercolumn. Can also handle text.
//Standard is classification, switch to regression via bool if you want regression. TRAINING WORKS FOR CLASSIFICATION ONLY.
//Passes to Buffer
func (p JSONBase) KNN(trainingtable, testtable, identifiercolumn string, knumber int, trainingmode, regression bool) {
	training := [][]float64{}
	trainingname := []string{}
	testing := [][]float64{}
	testingname := []string{}
	fmt.Println("KNN importing data...")
	t2i, real := p.grabindex(testtable)
	table1index, real2 := p.grabindex(trainingtable)
	bar := pb.StartNew(len(p.Table[table1index].Rows) + len(p.Table[t2i].Rows))
	if real == true {
		identindex, _ := p.grabcolumnindex(table1index, identifiercolumn)
		for index := range p.Table[table1index].Rows {
			bar.Increment()
			item := []float64{}
			for columnindex := range p.Table[table1index].Rows[index] {
				if columnindex == identindex {
					trainingname = append(trainingname, p.Table[table1index].Rows[index][identindex])
				} else {
					x, err := strconv.ParseFloat(p.Table[table1index].Rows[index][columnindex], 64)
					if err != nil {
						item = append(item, stringtofloat(p.Table[table1index].Rows[index][columnindex]))
					} else {
						item = append(item, x)
					}
				}
			}
			training = append(training, item)
		}
	}
	table2index, real2 := p.grabindex(testtable)
	if real2 == true {
		switch trainingmode {
		case true:
			trainingcolumn, _ := p.grabcolumnindex(table2index, identifiercolumn)
			for index := range p.Table[table2index].Rows {
				bar.Increment()
				item2 := []float64{}
				for columnindex := range p.Table[table2index].Rows[index] {
					if columnindex == trainingcolumn {
						testingname = append(testingname, p.Table[table2index].Rows[index][trainingcolumn])
					} else {
						x, err := strconv.ParseFloat(p.Table[table2index].Rows[index][columnindex], 64)
						if err != nil {
							item2 = append(item2, stringtofloat(p.Table[table2index].Rows[index][columnindex]))
						} else {
							item2 = append(item2, x)
						}
					}
				}
				testing = append(testing, item2)
			}
		case false:
			trainingcolumn, _ := p.grabcolumnindex(table2index, identifiercolumn)
			for index := range p.Table[table2index].Rows {
				bar.Increment()
				item2 := []float64{}
				for columnindex := range p.Table[table2index].Rows[index] {
					if columnindex == trainingcolumn {
						//
					} else {
						x, err := strconv.ParseFloat(p.Table[table2index].Rows[index][columnindex], 64)
						if err != nil {
							item2 = append(item2, stringtofloat(p.Table[table2index].Rows[index][columnindex]))
						} else {
							item2 = append(item2, x)
						}
					}
				}
				testing = append(testing, item2)
			}
		}
	}
	bar.Finish()
	fmt.Println("KNN processing...")
	knn(training, testing, trainingname, testingname, knumber, trainingmode, regression)
}
